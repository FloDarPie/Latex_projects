% !TEX root = ./main.tex


%-----------------------------------------------------------------------------
%    STARTER
%-----------------------------------------------------------------------------

\documentclass{backend/backend}
\usepackage{backend/font}
\usepackage{backend/colors}
\usepackage{backend/structure}
\usepackage{backend/informations}

%-----------------------------------------------------------------------------
%    PRESENTATION SLIDES
%-----------------------------------------------------------------------------

\begin{document}
\justifying

\begin{frame}
    \titlepage
\end{frame}

\comment{  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% COMMENTARY


\section*{Introduction}
\showtoctrue % active l'affichage des slides de transition

\begin{frame}{Introduction - 1}
    \pause
    \begin{exampleblock}{HACL*}
        \textit{"\textbf{H}igh \textbf{A}ssurance \textbf{C}ryptography \textbf{L}ibrary"}\footnote{\url{https://hacl-star.github.io/}} est une bibliothèque cryptographique, écrite en F* ("F star"), implémentant tous les algorithmes de cryptographie modernes et est prouvée mathématiquement sûre. 
        \smallbreak
        HACL* est notamment utilisé dans plusieurs systèmes de production tels que Mozilla Firefox, le noyau Linux, le VPN WireGuard...
    \end{exampleblock}
\end{frame}

\begin{frame}{Introduction - 2}
    \begin{block}{1996 : Paul C. Kocher, \textit{Timing Attacks on Implementations of Diffie-Hellman, RSA, DSS, and Other Systems} }
        Une mesure précise du temps requis par des opérations sur les clés secrètes permettrait à un attaquant de casser le cryptosystème.
    \end{block}
    \pause
    2003 : \citeauthor{270176} \citetitle{270176}\\
    \pause
    2011 : \citeauthor{stillPractical} \citetitle{stillPractical}
\end{frame}


\begin{frame}{Introduction - 3}
    \begin{enumerate}
        \item[\textbf{QR1}] Est-il possible de propager les garanties de sécurité pendant la compilation ?
        \item[\textbf{QR2}] Est-il possible d'automatiser la détection de ces failles sur des fichiers compilés ?
        \item[\textbf{QR3}] Est-il possible d'appliquer ces mécanismes pour assurer la vérification d'une bibliothèque cryptographique ?
    \end{enumerate}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%         SUMMARY
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Sommaire}
        \small
        \tableofcontents
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%         PREMIERE PARTIE
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Méthodes de protection et limitations}

\begin{frame}{État des lieux}
    \begin{blockSimple}{Usage sécurisé}
        \centering
        \begin{tikzpicture}[>={Latex[length=3mm,width=2.5mm]}, link/.style={->, very thick}]

        % Nœuds avec apparition progressive
        \node[src] (src) {Source};
        \node[comp, right=18mm of src] (cmp) {Compilateur};
        \node[asm, right=18mm of cmp] (asm) {Assembleur};

        % Flèches
        \draw[link] (src) -- (cmp);
        \draw[link] (cmp) -- (asm);

        \end{tikzpicture}
    \end{blockSimple}
\end{frame}


\begin{frame}{Analyse en remontée - 1}

    \begin{blockSimple}{Écrire en assembleur}
        \begin{columns}
            \begin{column}{0.3\textwidth}
                + Efficace\\
                + Contrôle total
            \end{column}
            \begin{column}{0.5\textwidth}
            - Restreint l'architecture et les usages\\
            - Beaucoup de connaissance spécifique au processeur ciblé
            \end{column}
        \end{columns}        
    \end{blockSimple}

    \vspace{6em}
    \begin{blockSimple}{}
        \centering
        \begin{tikzpicture}[scale=0.5, transform shape,>={Latex[length=3mm,width=2.5mm]}, link/.style={->, very thick}]

        % Nœuds avec apparition progressive
        \node[gray] (src) {Source};
        \node[gray, right=18mm of src] (cmp) {Compilateur};
        \node[asm, right=18mm of cmp] (asm) {Assembleur};

        % Flèches
        \draw[link] (src) -- (cmp);
        \draw[link] (cmp) -- (asm);

        \end{tikzpicture}
    \end{blockSimple}
\end{frame}


\begin{frame}{Analyse en remontée - 2}

    \begin{blockSimple}{Utilisation des compilateurs}
        \begin{columns}
        \begin{column}{0.5\textwidth}
            \begin{itemize}
                \item Constantine - 2021
                \item Jasmin - 2017
                \item \alt<1>{Raccoon - 2015}{\sout{Raccoon} - 2015}
                \item CompCert - 2008 (2019)
            \end{itemize}
        \end{column}
        \begin{column}{0.5\textwidth}
          \onslide<2>{
            \begin{itemize}
            \item[-] Couverture des architectures supportée
            \item[-] Informations à transmettre
            \item[-] Spécifications ne sont plus respectées
            \end{itemize}
          }
        \end{column}
    \end{columns}
    \end{blockSimple}
    \vspace{3em}
    \begin{blockSimple}{}
        \centering
        \begin{tikzpicture}[scale=0.5, transform shape,>={Latex[length=3mm,width=2.5mm]}, link/.style={->, very thick}]

        % Nœuds avec apparition progressive
        \node[gray] (src) {Source};
        \node[comp, right=18mm of src] (cmp) {Compilateur};
        \node[gray, right=18mm of cmp] (asm) {Assembleur};

        % Flèches
        \draw[link] (src) -- (cmp);
        \draw[link] (cmp) -- (asm);

        \end{tikzpicture}
    \end{blockSimple}
\end{frame}

\begin{frame}{Analyse en remontée - 3}

    \begin{blockSimple}{Programmation en temps constant}
        \begin{columns}
            \begin{column}{0.3\textwidth}
                + Position haut niveau\\
                + Couverture d'architectures importantes
            \end{column}
            \begin{column}{0.5\textwidth}
            - Rigueur et conception particulière des actions\\
            - Identification des points de fuites
            \end{column}
        \end{columns}        
    \end{blockSimple}

    \vspace{4em}
    \begin{blockSimple}{}
        \centering
        \begin{tikzpicture}[scale=0.5, transform shape,>={Latex[length=3mm,width=2.5mm]}, link/.style={->, very thick}]

        % Nœuds avec apparition progressive
        \node[src] (src) {Source};
        \node[gray, right=18mm of src] (cmp) {Compilateur};
        \node[gray, right=18mm of cmp] (asm) {Assembleur};

        % Flèches
        \draw[link] (src) -- (cmp);
        \draw[link] (cmp) -- (asm);

        \end{tikzpicture}
    \end{blockSimple}
\end{frame}


} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% COMMENTARY


\begin{frame}[fragile]{Opérations dangereuses}

    \begin{columns}
        \begin{column}{0.4\textwidth}
            \begin{blockSimple}{Opérations influantes :}
                \begin{itemize}
                    \item Accès mémoire
                    \item Décalage/rotation de valeurs \hfill\onslide<2>{(caché)}
                    \item Saut conditionnel
                    \item Division/multiplication
                \end{itemize}
            \end{blockSimple}
        \end{column}
        \pause
        \begin{column}{0.5\textwidth}
            \begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\tiny,linenos, gobble=8]{C}
                bool check_pwd(msg, pwd){
                if (msg.length != pwd.length){
                    return False
                }
                for(int i = 0; i < msg.length; i++){
                    if(msg[i] != pwd[i]){
                        return False
                    }
                }
                return True
                }
            \end{minted}
            \begin{tikzpicture}[scale = 0.5, transform shape]
            % Noeuds
            \node (start) [startstop] {check\_pwd};
            \node (valid) [right of=start, xshift=9cm, green] {\huge{$\checkmark$}};
            \draw [arrow] (start) -- (valid);
            
            \node (inputs) [below of = start, yshift=0.2cm] {(msg, pwd)};
            \node (if) [process] [right of=start, xshift=2cm] {if};
            \node (not) [above of=if, red] {\huge{$\times$}};
            \node (for) [process] [right of=if,, xshift=2cm] {for};
            \node (for1) [above of=for,xshift=1cm, red] {\huge{$\times$}};
            \node (for2) [right of=for1, red] {\huge{$\times$}};
            \node (for3) [right of=for2, red] {\huge{$\times$}};

            \draw [arrow] (if) -- (not);
            \draw [arrow] (for) -- (for1);
            \draw [arrow] (for) -- (for2);
            \draw [arrow] (for) -- (for3);

            \node (t) [above of=start] {};
            \node (a) [above of=valid, xshift=-0.3cm] {};
            \draw [arrow] (t) -- node[above left] {Temps ($\mu$s)} (a.west);
            
            \end{tikzpicture}
        \end{column}
    \end{columns}

\end{frame}

\begin{frame}{Plus de problème ?}
    \pause
    \begin{blockSimple}{Mauvaises nouvelles \alt<2>{?}{!}}
        2019 : \citeauthor{binsecRel2019}, \citetitle{binsecRel2019}\\
        \pause
        2024 : \citeauthor{schneider2024breakingbadcompilersbreak}, \citetitle{schneider2024breakingbadcompilersbreak}
    \end{blockSimple}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%         DEUXIEME PARTIE
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Outils de vérifications}
\begin{frame}{Spécialisations}
    \begin{columns}% t = alignement en haut
    % Colonne gauche : tableau
    \column{0.6\textwidth}
    \tiny
    \begin{tabular}{lccc}
        \toprule
        \textbf{Outil} & \textbf{Cible} & \textbf{Techn.} & \textbf{Garanties} \\
        \rowcolor{lightgray}
        ctgrind \cite{ctgrind} & Binaire & Dynamique & $\blacktriangle$ \\
        ABPV13 \cite{ABPV13} & C & Formel & $\bullet$ \\
        \rowcolor{lightgray}
        VirtualCert \cite{VirtualCert} & x86 & Formel & $\bullet$ \\
        ct-verif \cite{ctverif} & LLVM & Formel & $\bullet$ \\
        \rowcolor{lightgray}
        FlowTracker \cite{FlowTracker} & LLVM & Formel & $\bullet$ \\
        Blazer \cite{Blazer} & Java & Formel & $\bullet$ \\
        \rowcolor{lightgray}
        BPT17 \cite{BPT17} & C & Symbolique & $\blacktriangle$ \\
        MemSan \cite{MemSan} & LLVM & Dynamique & $\blacktriangle$ \\
        \rowcolor{lightgray}
        Themis \cite{Themis} & Java & Formel & $\bullet$ \\
        COCO-CHANNEL \cite{COCOCHANNEL} & Java & Symbolique & $\bullet$ \\
        \rowcolor{lightgray}
        DATA \cite{DATA1,DATA2} & Binaire & Dynamique & $\blacktriangle$ \\
        MicroWalk \cite{MicroWalk} & Binaire & Dynamique & $\blacktriangle$ \\
        \rowcolor{lightgray}
        timecop \cite{timecop} & Binaire & Dynamique & $\blacktriangle$ \\
        SC-Eliminator \cite{SCEliminator} & LLVM & Formel & $\bullet$ \\
        \rowcolor{lightgray}
        Binsec/Rel \cite{binsecRel2019} & Binaire & Symbolique & $\blacktriangle$ \\
        CT-WASM \cite{CTWASM} & WASM & Formel & $\bullet$ \\
        \rowcolor{lightgray}
        FaCT \cite{FaCT} & DSL & Formel & $\bullet$ \\
        haybale-pitchfork \cite{haybale-pitchfork} & LLVM & Symbolique & $\blacktriangle$ \\
        \bottomrule
    \end{tabular}

    % Colonne droite : légende et titre
    \column{0.5\textwidth}
    \textbf{Liste d’outils de vérification}\\[1ex]
    Source : \cite{notThatHardCT}\\[2ex]
    \begin{scriptsize}
        
        \textbf{Cible}
        \begin{itemize}
        \item[[C, Java]] Code source
        \item[Binaire] Binaire
        \item[DSL] Surcouche de langage
        \item[Trace] Trace d'exécution
        \item[WASM] Assembleur web
    \end{itemize}
    \textbf{Techn.}
    \begin{itemize}
        \item[Formel] Programmation formelle 
        \item[[*]] type d'analyse
    \end{itemize}
    \textbf{Garanties (attaques temporelles)}\\
        $\bullet$ = Analyse correcte,$\blacktriangle$ =  Limitée
    \end{scriptsize}
    \end{columns}
\end{frame}

\begin{frame}{L'outil idéal}
    \begin{exampleblock}{Binsec}
       \textit{Binary Security}\footnote{\url{https://binsec.github.io/}} est une plateforme open source développée pour évaluer la sécurité des logiciels au niveau binaire. 
       
       Il est notamment utilisé pour la recherche de vulnérabilités, la désobfuscation de logiciels malveillants et la vérification formelle de code binaire. Grâce à l'exécution symbolique, Binsec peut explorer et modéliser le comportement d'un programme pour détecter des erreurs; cette détection est réalisée en association avec des outils de fuzzing et/ou des solveurs SMT.
    \end{exampleblock}
\end{frame}

\section{Automatismes}
\begin{frame}{Premiers scripts}
    
\end{frame}

\begin{frame}{Cahier des charges}
    
\end{frame}

\section{Érysichthon}
\subsection{Conception générale}
\begin{frame}{Conception générale}
    graphes
\end{frame}

\begin{frame}{Spécifications architecturales}
    graphes
\end{frame}

\begin{frame}{Constructions en modules}
    graphes
\end{frame}

\subsection{Andhrímnir}
\begin{frame}{Andhrímnir}
    Besoins
\end{frame}

\begin{frame}{Conception générale}
    graphes
\end{frame}

\section{Résultats}
\begin{frame}{Premières passes}
    graphes
\end{frame}

\begin{frame}{Analyses}
    graphes
\end{frame}

\section*{Conclusion}
\begin{frame}{}
    \begin{center}
        \Huge
        \textbf{Conclusion}
    \end{center}
\end{frame}

\begin{frame}{Références}
    \tiny
    \printbibliography
\end{frame}




\end{document}

