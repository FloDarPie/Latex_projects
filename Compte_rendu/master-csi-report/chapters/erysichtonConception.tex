\chapter{Implémentations pour un usage industriel}
\label{chap:erysichtonConception}




\section{Identification des besoins et spécificités}

On a pus voir grâce aux chapitres précédents que la conception et l'implémentation d'une système sécurisé est un problème difficile. Une première étape est de concevoir des primitives et protocoles mathématiquement sécurisés. Une seconde étape est de s’assurer que leurs implémentations sont effectivement sécurisées, d’abord d’un point de vue mathématique contre des attaques logiques (aspect fonctionnel : le code implémente correctement les bons concepts cryptographiques), mais aussi contre des attaques très bas niveau, les attaques temporelles. \medbreak

Avec l'objectif de concevoir un sytème sûr, il nous faut donc identifier toutes les tâches à réaliser pour arriver à bout de ce projet. En plus de ce travail de planification, l'identification et l'intégration d'outils déjà implémenté nous permettra de d'avancer plus rapidement vers cet objectif.\smallbreak


\subsection*{Point de départ}

En reprenant ces deux étapes, on va identifier quels sont nos leviers et nos possibilités pour un développeur pour avancer dans la conception de notre graal.\smallbreak

La première étape de conception de primitives cryptologiques et de protocole n'est pas du ressort du développeur. Elle appartient aux cryptologues et aux chercheurs en sécurité mathématique. Ce sont eux qui concoivent et maintiennent des librairies cryptographiques, des boîtes à outils qui propose les briques de sécurité nécessaires aux systèmes sécurisés.\medbreak

Plusieurs librairies existent \cite{OpenSSL, BearSSL, polubelova2020haclxn} et remplissent différents objectifs :  rétro-compatiblité, politique temps constant, \etc. Notre choix est à réaliser en fonction des spécifités du produits que l'on cherche à déployer.\medbreak

La seconde étape est à distinguer en deux parties. Cette opération de vérification de la sécurité de l'implémentation peut-être réaliser sur le produit fini et sur les librairies employés par le produit. Comme introduit, cette étape à pour objectif la vérification formelle du code du programme et la vérification matérielle au niveau assembleur.\medbreak

Utiliser la bibliothèque \textbf{Hacl*} \cite{polubelova2020haclxn, Hacl*} permet d'avancer la première étape et la première partie de la seconde étape. Cette bibliothèque a été conçue formellement et vient avec les preuves mathématique de la sécurité de son implémentation. Comme présenté en \nameref{chap:prelude}, cette librairie est programmée en F*. Le projet permet une exploitation en C et en assembleur \cite{Hacl*}.\medbreak

En revanche, la seconde étape de la seconde partie nous demande une vérification au niveau de l'assembleur. Si certaine partie de cette librairie sont codées en assembleur, la majorité du projet reste du F* traduit vers C. Il faut réaliser une analyse. Dans le cadre de cette étude, l'outil d'analyse binaire retenu pour réaliser cette tâche est \textbf{Binsec}. Cette outil est implémenté en Ocaml et est maintenu par une équipe de chercheurs ingénieurs géographiquement proche de l'équipe PROSECCO Inria. Cet avantage permet des échanges plus directs et donc une facilité quand à la mise en place du projet.\medbreak

L'objectif est donc d'analyser Hacl* dans son entièreté. Avec cette analyse complète, si elle est correcte, alors les deux étapes de réalisation d'un système sûr seront réalisées. Cela signifie que la première librairie cryptographique formellement sûre et résistante aux attaques temporelles sera conçus.

\subsection*{Objectifs à réaliser}

Sans reprendre les explications du fonctionnement de Binsec, voir \textcolor{red}{"ref vers fonctionement de Binsec"}, l'analyse se réalise sur un fichier binaire à l'aide d'un carnet d'instructions à préciser. Avec ce point de départ, on peut commencer à construire notre carnet de spécifications.

\textbf{Fichier binaire.} Il faut donc des fichiers binaires à fournir à Binsec. Or comme chacun le sait, plus un binaire est imposant, plus son analyse est difficile. Et comme Binsec emploi l'analyse symbolique, explorer un binaire imposant a un coût de mémoire quadratique sur le parcours des instructions du binaire. L'idéal est donc d'analyser plein de petits fichiers binaires.\smallbreak

\textbf{Analyse complète.} Chaque fonction de Hacl* doit être analysée. En poursuivant la condition précédente, on peut essayer de concevoir un binaire par fonction analysé. On distribue ainsi l'analyse et on parcourt ainsi toute les fonctions présentent dans la librairie.\medbreak

\textbf{Analyse correcte.} Si on se rappel comment fonctionne les optimisations (voir le tableau \ref{tab:compile_option}) il faut faire attention avec certaines optimisations qui simplifient le code par soustraction d'oprations. Le fichier ne doit pas seulement contenir un appel de fonction, il faut une légère mise contexte.

\begin{listing}[!ht]
    \caption{Code d'anlayse de la fonction Hacl\_AEAD\_Chacha20Poly1305\_Simd128\_encrypt, testé lors de la prise main de Binsec et Hacl*}
    \label{lst:prise_en_main}
    \begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,fontsize=\footnotesize,linenos, gobble=8]{C}
        #include <stdlib.h>

        #include "Hacl_AEAD_Chacha20Poly1305_Simd128.h"

        #define BUF_SIZE 16384
        #define KEY_SIZE 32
        #define NONCE_SIZE 12
        #define AAD_SIZE 12
        #define TAG_SIZE 16

        uint8_t plain[BUF_SIZE];
        uint8_t cipher[BUF_SIZE];
        uint8_t aead_key[KEY_SIZE];
        uint8_t aead_nonce[NONCE_SIZE];
        uint8_t aead_aad[AAD_SIZE];
        uint8_t tag[16];

        int main (int argc, char *argv[])
        {
        Hacl_AEAD_Chacha20Poly1305_Simd128_encrypt
            (cipher, tag, plain, BUF_SIZE, aead_aad, AAD_SIZE, aead_key, aead_nonce);
        exit(0);
        }
    \end{minted}
\end{listing}

De même, comme nos fichiers analysés font appel à la librairie extérieur Hacl*, l'emploi de l'option \texttt{-static} est nécessaire pour prévenir la mise place de lien vers la librairie partagée dans le ficher binaire. Cette option ne nuit pas à la qualité de l'analyse, elle permet en revanche d'avoir tous les éléments sous la main lorsque l'on déassemble un fichier binaire. Retirer cette option lors de la compilation, c'est se rajouter des lourdeurs et rallonger la temps requis pour la vérification manuelle d'un fichier.\medbreak

\textbf{Couverture de compilateur.} Les travaux de \citeauthor{schneider2024breakingbadcompilersbreak} \cite{schneider2024breakingbadcompilersbreak} ont clairement mis en évidence que le choix du compilateur est à considérer. Il faut donc identifier quel compilateur nous permet d'avoir des fichiers binaires les plus sécurisés. On peut aussi identifier quels optimisations produisent la rupture de sécurité dans le binaire en étudiant plus en avant le comportement de ceux-ci.

\textbf{Couverture d'architectures.} x86\_64 et ARM sont les architectures matérielles les plus répandues dans le monde. Étendre l'analyse vers différentes plateformes et observer les différences qui émergent nous permettraient d'avancer dans la direction de la conception d'une librairie cryptographique universelle. On aussi étendre l'analyse vers d'autres architectures comme PowerPC ou RiscV.\medbreak


\textbf{Automatisation.} Faire cette analyse sur un fichier binaire, comme le code \ref{lst:prise_en_main}, avec trois axes de compléxité (complétude, de la couverture d'architectures et des compilateurs) n'est pas envisageable à la main. Il faut absolument que cette analyse soit automatisée.


\section{Initialisation et tests variés}

Dans le cadre de la programmation sécuritaire, où sont développés les systèmes avec pour objectif de un accident par siècle (métros automatiques, trains, avions\dots), les projets sont conçus selon le principe du cycle en V. Au contraire de la méthode Agile où on avance vers les problèmes en les résolvants au fur et à mesure, avec ce principe le développement est beaucoup plus long mais permet d'esquiver les problèmes qui, dans son contexte d'usage, peuvent entraîner des décés.


\begin{figure}[!ht]
    \caption{Cycle en V}
    \label{fig:cycle_en_V}
    \centering
   \begin{tikzpicture}[
        auto,
        mynode/.style={draw, text width=2.5cm, align=center, font=\small},
        myarrow/.style={-Stealth, thick}
    ]

    % Nodes for the V-model
    \node[mynode] (req) {Besoin et exigences};
    \node[mynode, xshift=1cm, yshift=-0.5cm, below of=req] (spec) {Spécification système};
    \node[mynode, xshift=1cm, yshift=-0.5cm, below of=spec] (design) {Conception globale};
    \node[mynode, xshift=1cm, yshift=-0.5cm, below of=design] (detaildesign) {Conception détaillée};
    \node[mynode, xshift=1.3cm, yshift=-0.5cm, below of=detaildesign] (coding) {Codage et implémentation};
    \node[mynode, xshift=2cm, yshift=0.5cm, above of=coding] (unit) {Tests unitaires};
    \node[mynode, xshift=1cm, yshift=0.5cm, above of=unit] (integration) {Tests d'intégration};
    \node[mynode, xshift=1cm, yshift=0.5cm, above of=integration] (system) {Tests système};
    \node[mynode, xshift=1cm, yshift=0.5cm, above of=system] (acceptance) {Tests d'acceptation};
    \node[mynode, above of=acceptance] (maintenance) {Maintenance};

    % Arrows for the V-model
    \draw[myarrow] (req) -- (spec);
    \draw[myarrow] (spec) -- (design);
    \draw[myarrow] (design) -- (detaildesign);
    \draw[myarrow] (detaildesign) -- (coding);
    \draw[myarrow] (coding) -- (unit);
    \draw[myarrow] (unit) -- (integration);
    \draw[myarrow] (integration) -- (system);
    \draw[myarrow] (system) -- (acceptance);
    \draw[myarrow] (acceptance) -- (maintenance);

    % Arrows for the verification and validation
    \draw[myarrow, dashed, opacity=0.5] (unit.west) -- (detaildesign);
    \draw[myarrow, dashed, opacity=0.5] (integration.west) -- (design);
    \draw[myarrow, dashed, opacity=0.5] (system.west) -- (spec);
    \draw[myarrow, dashed, opacity=0.5] (acceptance.west) -- (req);

    % Legend
    \node[draw, opacity=0.5] (legend1) at (10,-2) {};
    \draw[myarrow, dashed, opacity=0.5] (legend1.east) -- ++(1,0);
    \node[anchor=west] at (11,-2) {Vérifications};

    \node[draw] (legend2) at (10,-3) {};
    \draw[myarrow] (legend2.east) -- ++(1,0);
    \node[anchor=west] at (11,-3) {Étapes successives};

    \end{tikzpicture}
\end{figure}
\begin{center}
    \rule{0.75\textwidth}{1pt}
\end{center}

Appliqué cette méthode à l'entièreté de ce projet n'est pas envisageable à cause du coût temporel qui est très élévé. On va se concentrer sur la réalisation d'une preuve de concept et se concentrer sur la partie automatisation. La conception du produit sera minimale et le développement des couvertures sera soumis à un futur travail.

\subsection*{Identification des besoins et exigences}

On a déjà conçus notre carnet d'exigence, en revanche on ne connais pas le comportement des outils que l'on souhaite employer. La première opération est de s'approprier le fonctionnement des outils que l'on s'apprête à employer. Le code \ref{lst:prise_en_main} est un exemple de test réalisé dans cette phase du projet.

Binsec est un outil uniquement utilisable au travers d'un terminal. Il s'invoque avec son alias, le binaire à analyser et les options de l'analyse qui sera effectué :

\begin{listing}[!ht]
    \caption{Commande Binsec basique}
    \label{lst:commande_binsec}
    \begin{minted}{shell}
$ binsec -sse -sse-script $(BINSEC_SCRIPT) -checkct $(BINARY)
    \end{minted}
\end{listing}

L'option \texttt{-sse} permet d'activer l'analyse par exécution symbolique, \texttt{-sse-script} associer à un fichier (ici \texttt{BINSEC\_SCRIPT}) permet d'instruire notre analyse, préciser des stubs\footnote{Terme anglais du lexique de la rétro-ingénierie; module logiciel simulant la présence d'un autre.} et des initialisations, enfin \texttt{-checkct} active la vérification des propriétés temps constant au sein du fichier binaire indiqué par \texttt{BINARY}.\medbreak

Cette phase permet de tester plusieurs fonctions de Hacl* et surtout de se familiariser avec le langage d'instruction qu'admet l'option \texttt{-sse-script}. Un tutoriel complet est accessible pour comprendre le fonctionnement l'outil Binsec depuis sa page officielle\footnote{https://binsec.github.io/}.

\begin{listing}[!ht]
    \caption{Instructions permettant de trouver le mot d'un passe d'un binaire exercice}
    \label{lst:exemple_binsec}
    \begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,linenos]{bash}
starting from core with
  argv<64> := rsi
  arg1<64> := @[argv + 8, 8]
  size<64> := nondet            # 0 < strlen(argv[1]) < 128
  assume 0 < size < 128
  all_printables<1> := true
  @[arg1, 128] := 0
  for i<64> in 0 to size - 1 do
    @[arg1 + i] := nondet as password
    all_printables := all_printables && " " <= password <= "~"
  end
  assume all_printables
end

replace <puts>, <printf> by
return
end

reach <puts> such that @[rdi, 14] = "Good password!"
then print ascii stream password

cut at <puts> if @[rdi, 17] = "Invalid password!"

halt at <printf>
\end{minted}
\end{listing}

Ce code présenté ici est issu du tutoriel de Binsec et permet de réaliser une attaque sur un binaire issu d'une plateforme d'apprentissage à la sécurité informatique. L'exerice consistant à retrouver le mot de passe caché d'un binaire. Dans le cadre de notre exercice d'analyse de la politique temps constant, le script \ref{lst:analyse_simple_binsec} est plus simple.\medbreak

Ce script a été conçu avec pour objectif de vérifier les résultats apportés par \cite{schneider2024breakingbadcompilersbreak} concernant une fuite présente sur la fonction <<\textit{FStar\_UInt64\_eq\_mask}>> et d'étendre l'analyse vers d'autres architectures. Dans une première démarche d'automatisation, ce code à été généré automatiquement par un script shell. On voit ici que l'analyse ne parcourt pas l'entièreté du binaire, seulement 8 sections sont chargés (sur 24). L'analyse commence à l'appel de la fonction \texttt{main} et se termine à la ligne 8 avec une adresse de fin. Cette addresse de fin est produite par le script shell pour attraper la fin de la fonction \texttt{main}. 

\begin{listing}[!ht]
    \caption{Instructions permettant d'analyser le code \ref{lst:Hacl_masking} compilé vers RiscV-32}
    \label{lst:analyse_simple_binsec}
    \begin{minted}[frame=lines,framesep=2mm,baselinestretch=1.2,linenos]{bash}
load sections .plt, .text, .rodata, .data, .got, .got.plt, .bss from file

secret global  r, cin, y, x

starting from <main>

with concrete stack pointer
halt at  0x0000000000000464
explore all

\end{minted}
\end{listing}


Ce modèle, qui nous servira de base pour la suite du développement, a permis une analyse rapide entre différents compilateurs et différentes architectures : 


\begin{figure}[!ht]
    \caption{Tableau de résultats d'analyse Binsec pour architecture ARMv7}
    \label{tab:resultats_amv7}
    \centering
    \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        \rowcolor{blue!10}
        \cellcolor{inria-2024-gris-bleu!20}\textbf{opt}\textbackslash\textbf{fonction analysée} & \multicolumn{5}{c|}{\textbf{cmovznz4}} \\
        \hline
        \rowcolor{blue!30}
        \textbf{Clang+LLVM} & \textbf{14.0.6} & \textbf{15.0.6} & \textbf{16.0.4} & \textbf{17.0.6} & \textbf{18.1.8} \\
        \hline
        \rowcolor{orange!30!red!50}
        \textbf{-O2} & \cellcolor{green!60}\checkmark & \cellcolor{green!60}\checkmark & \cellcolor{green!60}\checkmark  & \cellcolor{green!60}\checkmark  & \cellcolor{green!60}\checkmark  \\
        \hline
        \rowcolor{orange!30!red!50}
        \textbf{-O3} & \cellcolor{green!60}\checkmark & \cellcolor{green!60}\checkmark  & \cellcolor{green!60}\checkmark  & \cellcolor{green!60}\checkmark  & \cellcolor{green!60}\checkmark  \\
        \hline
        \rowcolor{orange!30!red!50}
        \textbf{-Os} & \cellcolor{green!60}\checkmark  & \cellcolor{green!60}\checkmark  & \cellcolor{green!60}\checkmark  & \cellcolor{green!60}\checkmark  & \cellcolor{green!60}\checkmark  \\
        \hline
        \rowcolor{orange!30!red!50}
        \textbf{-Oz} & \cellcolor{green!60}\checkmark  & \cellcolor{green!60}\checkmark  &  \cellcolor{green!60}\checkmark  &  \cellcolor{green!60}\checkmark  &  \cellcolor{green!60}\checkmark \\
        \hline
    \end{tabular}
\end{figure}



\begin{figure}[!ht]
    \caption{Tableau de résultats d'analyse Binsec pour architecture Risc-V}
    \label{tab:resultats_riscv32}
      \begin{tabular}{|c|cc|cc|}
        \hline
        \rowcolor{blue!10}
        \cellcolor{inria-2024-gris-bleu!20}\textbf{opt}\textbackslash\textbf{fonction analysée} & \multicolumn{2}{c|}{\textbf{cmovznz4} - 64 bits} & \multicolumn{2}{c|}{\textbf{cmovznz4} - 32 bits} \\
        \hline
        \rowcolor{blue!30}
        \textbf{Compilateur et architecture} & gcc 15.1.0 & clang 19.1.7 & gcc 15.1.0& clang 19.1.7 \\
        \hline
        \rowcolor{orange!30!red!50}
        \textbf{-O2} &  \cellcolor{green!60}\checkmark & \cellcolor{red!60}$\times$ & \cellcolor{green!60}\checkmark & \cellcolor{red!60}$\times$ \\
        \hline
        \rowcolor{orange!30!red!50}
        \textbf{-O3} &  \cellcolor{green!60}\checkmark & \cellcolor{red!60}$\times$ & \cellcolor{green!60}\checkmark & \cellcolor{red!60}$\times$ \\
        \hline
        \rowcolor{orange!30!red!50}
        \textbf{-Os} &  \cellcolor{green!60}\checkmark & \cellcolor{red!60}$\times$ & \cellcolor{green!60}\checkmark & \cellcolor{red!60}$\times$ \\
        \hline
        \rowcolor{orange!30!red!50}
        \textbf{-Oz} &  \cellcolor{green!60}\checkmark & \cellcolor{red!60}$\times$ & \cellcolor{green!60}\checkmark & \cellcolor{red!60}$\times$ \\
        \hline
      \end{tabular}
\end{figure}



% \cellcolor{green!60}\checkmark


% \cellcolor{orange!60}\textasciitilde 

% \cellcolor{red!60}$\times$ 








