\chapter*{Introduction}

Le développement sécurisé est une tâche ardue. Si nous portons notre regard vers le langage de programmation C, un guide \cite{progC_guide} d'apprentissage du langage est complet en 133 pages, tandis qu'un guide pour le développement sécurisé\cite{anssi_guideForSecureprogramming} produit par l'\indexed{Anssi} comprend 182 pages. Cette comparaison met en évidence la discipline requise par le développeur pour faire de la programmation sécurisée; en plus des connaissances en cryptologie, en architecture matérielle et en programmation bas niveau nécessaires pour améliorer l'efficacité de son programme. \medbreak

Malheureusement, malgré ces compétences, des erreurs peuvent être commises puis exploitées pour réaliser des attaques sur ces systèmes sécurisés. Il existe de nombreuses classes d'attaques, certaines exploitant les défauts de conception (type A) tandis que d'autres utilisent les caractéristiques matérielles (type B). Pour limiter ces effets ces risques, la pratique de la programmation formelle permet de contraindre le développeur et d'empêcher l'apparition de ces erreurs. La production de preuves formelles du code à l'issue de cet exercice permet d'avoir des garanties contre les attaques de type A.\medbreak

En revanche, pour se défendre contre des attaques de type B, dépendantes du matériel supportant le programme, il est plus difficile d'avoir une méthode générique. Notamment à cause de toutes les variations existantes (\eg : architectures variés, différentes versions de supports physiques, \etc). Actuellement, la solution la plus courante consiste à identifier les attaques existantes afin d'ajouter les contre-mesures adéquates permettant d'obtenir un système sécurisé. Une sous-classe d'attaques continue malgré tout de résister à cette méthode : les attaques temporelles.\medbreak

Découvertes par Paul Kocher en 1996 \cite{crypto-1996-1469}, il les décrit comme <<\textit{une mesure précise du temps requis par des opérations sur les clés secrètes, permettrait à un attaquant de casser le cryptosystème}>>. Face à cette menace, l'enjeu d'avoir un code \textit{\indexed{achrognostique}}\footnote{Néologisme de Thomas Pornin dans son article \textit{Constant-Time Code: The Pessimist Case} \cite{constantTimePornin} pour désigner un code sans connaissance de temps} vient s'ajouter aux pratiques de programmation sécurisée. Et pourtant, si contre les attaques de type A nous arrivons à concevoir des preuves mathématiques de sécurité associées à nos systèmes sécurisés, les garanties contre les attaques de type B sont plus faibles ou inexistentes.\medbreak

En 2024, les travaux de \citeauthor{schneider2024breakingbadcompilersbreak} \cite{schneider2024breakingbadcompilersbreak} prouvent qu'un usage inadapté de compilateur sur un système sécurisé introduit des failles exploitables. Ces résultats, observables partiellement avec des travaux antérieurs (par exemple \cite{binsecRel2019}), montrent qu'un usage inadéquat d'options fournies au compilateur optimise un code prouvé sécurisé et retire les protections indiquées par le développeur. Cela nous amène à plusieurs questions de recherche (QR) auxquelles nous tenterons de répondre dans ce document.
\begin{enumerate}
    \item[\textbf{QR1}] Est-il possible de propager les garanties de sécurité pendant la compilation ?
    \item[\textbf{QR2}] Est-il possible d'automatiser la détection de ces failles sur des fichiers compilés ?
    \item[\textbf{QR3}] Est-il possible d'appliquer ces mécanismes pour assurer la vérification d'une bibliothèque cryptographique ?
\end{enumerate}

Les réponses à ces questions permettraient de développer des systèmes sécurisés, communs entre différents supports et architectures, ainsi que d'avoir de fortes garanties de sécurité. Pour la suite du document nous emploierons le terme de \textit{binaire} ou \textit{fichier binaire} pour nous référer aux fichiers compilés.\smallbreak

Ce mémoire se compose en deux parties. La première partie présente les attaques temporelles, leur impact, comment s'en protéger et les outils à disposition pour s'en prémunir. Dans la deuxième partie nous verrons les travaux nécessaires à la conception et à l'implémentation d'un outil de détection automatique de ces attaques temporelles, ainsi que les premiers résultats apportés par cette démarche novatrice.\medbreak

Ce mémoire a été réalisé au sein du centre Inria de Paris en collaboration avec le centre CEA de Paris-Saclay.

